# Default values for qtest-manager-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# universal namespace for all qtest app services
namespace:
  name: qtest
reloader:
  enabled: false
rollouts:
  enabled: false
  ingressClassName: alb
  strategy:
    canary:
      maxSurge: "25%"
      maxUnavailable: 0
  steps:
    - setWeight: 20
    # if prometheus metrics are enabled
    # - analysis:
    #     templates:
    #     - templateName: success-rates
    #       clusterScope: true
    #     args:
    #     - name: service-name
    - setWeight: 50
    - pause: {duration: 10s}
deployments:
  enabled: true
liquibase:
  annotations:
    helm.sh/hook: pre-install, pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation, hook-succeeded
    # argocd.argoproj.io/hook: PreSync
    # argocd.argoproj.io/hook-delete-policy: HookSucceeded, BeforeHookCreation
  configmapAnnotations:
    helm.sh/hook: pre-install, pre-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation, hook-succeeded
    # argocd.argoproj.io/hook: PreSync
    # argocd.argoproj.io/sync-wave: "-5"
    # argocd.argoproj.io/hook-delete-policy: HookSucceeded, BeforeHookCreation
annotations: {}
podAnnotations: {}
env: []
image:
  repository: tricentisimage/qtest-mgr
  liquibase: tricentisimage/qtest-mgr-liquibase
  pullPolicy: IfNotPresent
  tag: "11.0.5-f41702f"
  liquibasetag: "11.0.5-f41702f"
  liquibasepullpolicy: IfNotPresent
imageCredentials:
  enabled: false
  # name: ""
  # registry: ""
  # username: ""
  # password: ""
  # email: ""
  # existingImageCredentials: ""
secrets:
  enabled: false
  # existingConfigs: ""
serviceAccount:
  create: true
  name:
  annotations: {}
  automountsatoken: false
service:
  type: LoadBalancer
  annotations: {}
  port: 8080
  targetPort: 8080
  targetSigSciPort: 8081
  serviceName: mgr-service
  # servicePortHttp: 80
  # servicePortHttps: 443
  # servicePortHttpName: http
  # servicePortHttpsName: https
shareProcessNamespace: "true"
extraInitContainers: []
extraContainers: []
extraArgs: []
extraEnv: []
extraVolumeMounts: []
extraVolumes: []
qTestManager:
  analyticsUrlBase: "http://local"
  configureTimeoutTokenApplicationEnabled: true
  async:
    maxCpu: 101
    databaseCpu: 101
  client:
    jdbc:
      postgresUrl: "jdbc:postgresql://postgres.local:5432/qtest"
      postgresUserName: "qtest"
      postgresPassword: ""
      postgresReadOnlyUrl: "jdbc:postgresql://postgres_replica.local:5432/qtest"
      postgresReadOnlyUserName: "qtest"
      postgresReadOnlyPassword: ""
      sslEnable: false
      sslMountPath: ""
      sslPath: ""
      cert: ""
    dbcp:
      testWhileIdle: 1
  cors:
    allowed:
      all: true
      domains: ""
  elasticSearch:
    init: false
    disable: true
    scheme: http
    host: elasticsearch.local
    port: 9200
    permittedClients: ""
    maximumObjectsPerIndexRequest: 1000
  attachmentFolderPath: /usr/local/tomcat/temp
  licenseFolderPath: /usr/local/tomcat/temp
  blobStorage:
    region: us-east-1
    sharedBucket: "qtest"
    type: disk_storage
  s3:
    folder: qtest/manager
    scanUrl: https://clamav-13.container-dev.qtestdev.com
    accessKey: ""
    secretKey: ""
  security:
    csrf:
      source:
        trust:
          pattern: ""
  serverAppUseSecureCookie: true
  serverAppSSLRequired: false
  preUrl: http://nephele.qtest.local
  preUrlHttps: https://nephele.qtest.local
  qasymphonyUrlPostfix: .qtest.local
  qasDirectoryAddress: http://qtest-auth.local/tc-auth
  kafka:
    enable: false
    bootstrapAddress: "kafka-broker.local:9092"
    schemaRegistryUrl: "https://schema-registry.local"
  preSessionUrl: "https://sessions.qtest.local"
  pulseUrlBase: "https://pulse.qtest.local"
  insightsUrl: "http://insights-service:8080"
  launchUrlBase: "https://launch.qtest.local"
  tdmSettingUrl: "http://parameters.qtest.local"
  notification:
    urlExternal: "https://notification.qtest.local"
    urlInternal: "http://notification.qtest.local"
  pentaho:
    usingClientId: ""
  qTest:
    serverMapUrl: "http://qtest.local/public/jira-widget/server-map"
    instance: US
    ODPrivate: false
    request:
      nonce:
        disabled: true
        mode: HighPrecision
  report:
    httpUrl: http://localhost/pentaho
    url: https://localhost/pentaho
  requestExecutionTimeUpperThreshold: -1
  siteFieldTemplateAssigningProjectBatchSize: 50
  taskExecutionTimeUpperThreshold: -1
  mail:
    host: "smtp.local"
    port: 465
    userName: "qtest"
    password: ""
    supportEmailAddress: supports@tricentis.com
    blockExternal: true
  emailchange:
    allowClients: ""
  integration:
    jira:
      testConnectionLegacyEndpointClients: ""
  data:
    volumeMount: /mnt/data/qtest
  vera:
    auto:
      testrun:
        beta:
          clients: -1
  secret:
    volumeMount: /mnt/secrets/storage
    appVolumeMount: /mnt/secrets/storage/..data
ui:
  action:
    task:
      executor:
        poolSize: 2
  asyncThreadNumber: 40
  backgroundEventMaxThreshold: 2000
  client:
    dbcp:
      maxActive: 200
      readOnlyMaxActive: 100
  springProfilesActive: postgres,readOnlyEnable
  useriqEnabled: false
api:
  appName: app
  asyncThreadNumber: 100
  background:
    event:
      maxThreshold: 15000
      apiThreshold: 300
      cleanUpInterval: "3600000"
      jiraCloudThreshold: 500
      jiraServerThreshold: 20
      oldDefectTrackingSystemsThreshold: 20
      testExecutionApiRetryTime: 1
      testExecutionApiThreshold: 2
  client:
    dbcp:
      maxActive: 400
  springProfilesActive: postgres,readOnlyEnable
poller:
  appName: notification
  asyncThreadNumber: 100
  background:
    event:
      maxThreshold: 2000
      cleanUpInterval: "3600000"
  client:
    dbcp:
      maxActive: 150
  schedulerBlobHandleMaxRetryTimes: 5
  siteFieldTemplateAssigningProjectBatchSize: 50
  testconductorAppPath: testconductor-app.localhost.xml
  queuePublisherMaxDequeue: 300
  springProfilesActive: postgres
notification:
  action:
    task:
      executor:
        poolSize: 2
  appName: notification
  asyncThreadNumber: 100
  background:
    event:
      maxThreshold: 2000
      apiThreshold: 20
      cleanUpInterval: "3600000"
      jiraCloudThreshold: 20
      jiraServerThreshold: 20
      oldDefectTrackingSystemsThreshold: 20
      testExecutionApiRetryTime: 0
      testExecutionApiThreshold: 1
  client:
    dbcp:
      maxActive: 300
  springProfilesActive: postgres,backgroundQueue
  schedulerBlobHandleMaxRetryTimes: 5
  queuePublisherMaxDequeue: 300
testconductor:
  environment:
    isOnPremise: true
    singleInstance: true
    od:
      single: production
      ui: production
      api: production
      poller: notification.production
      notification: notification.production
    op:
      single: onpremise
      ui: ui.onpremise
      api: api.onpremise
      poller: poller.onpremise
      notification: notification.onpremise
#### Ingress/IngressClass (> K8s 1.18-1.22+) #####
ingressClass:
  enabled: true
  # existingclassName:
  labels: {}
  controller: ingress.k8s.aws/alb
  isDefaultClass: true
  # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
  fallbackApiVersion: ""
ingress:
  enabled: true
  name: mgr-ingress
  labels: {}
  annotations: {}
  canary:
    annotationPrefix: alb.ingress.kubernetes.io
    annotations: {}
    # canary-by-header: []
    # canary-by-header-pattern: []
  hosts: []
  # host: qtest.svc.com

  paths: []
  # - path: /api
  #   pathType: Prefix
  #   backendServiceName: mgr-service-api
  #   backendPort: 8080
  # - path: /api2
  #   pathType: Prefix
  #   backendServiceName: mgr-service-api
  #   backendPort: 8080
  # - path: /api/v3
  #   pathType: Prefix
  #   backendServiceName: mgr-service-api
  #   backendPort: 8080
  # - path: /public/integration/webhookcallback2
  #   pathType: Prefix
  #   backendServiceName: mgr-service-api
  #   backendPort: 8080
  # - path: /realtime
  #   pathType: Prefix
  #   backendServiceName: mgr-service-notification
  #   backendPort: 8080

  extraPaths:
    - path: /
      pathType: Prefix
      backendServiceName: mgr-service
      backendPort: 8080
  tls: []
  # - secretName: qtest-svc-tls
  #   hosts:
  #     - svc.qtest.com
  https: false
# CD Pipeline use only
chaos:
  enabled: false
workflow:
  enabled: false
  annotations: {}
  adminModeNamespace: litmus
  serviceAccountName: ""
  podGC: OnWorkflowSuccess
  secret: ""
  revision: ""
  postman:
    repo: ""
    image: public.ecr.aws/b8y7a2x6/argo-agent:ubuntu.2
# Metrics for nginx ingress controller for application and cluster analysis
metrics:
  enabled: false
  prometheus:
    address: ""
    query: ""
persistence:
  enabled: true
  annotations: {}
  ## Specify an existing volume claim instead of creating a new one.
  ## When using this option all following options like storageClass, accessMode and size are ignored.
  # existingClaim: qtest-onpremise-pvc

  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ## set, choosing the default provisioner.  (gp2 on AWS, standard on
  ## GKE, AWS & OpenStack)
  ##
  storageClass:
  accessMode: ReadWriteMany
  size: 10Gi
  ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
  volumes: []
  ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
  mounts: []
# VPA values
vpaAutoscaling:
  enabled: false
  updatePolicy:
    updateMode: "Off"
# HPA values
autoscaling:
  enabled: true
  minReplicas:
    ui: 1
    api: 1
    notification: 1
    poller: 1
    default: 1
  maxReplicas:
    ui: 3
    api: 3
    notification: 3
    poller: 1
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 70
  healthApiPath: /health-checker
resourceQuota:
  enabled: true
  hard:
    limits.cpu: "80"
    limits.memory: 400Gi
    requests.cpu: "64"
    requests.memory: 160Gi
    pods: "25"
    persistentvolumeclaims: "50"
    requests.storage: 500Gi
limitRange:
  limits:
    - max:
        cpu: "2"
        memory: 16Gi
      default:
        cpu: "2"
        memory: 16Gi
      defaultRequest:
        cpu: "2"
        memory: 4Gi
      type: Container
resources: {}
# We usually recommend not to specify default resources and to leave this as a conscious
# choice for the user. This also increases chances charts run on environments with little
# resources, such as Minikube. If you do want to specify resources, uncomment the following
# lines, adjust them as necessary, and remove the curly braces after 'resources:'.
# limits:
#   cpu: 100m
#   memory: 128Mi
# requests:
#   cpu: 100m
#   memory: 128Mi

## Readiness, liveness and startup probes
livenessProbe:
  httpGet:
    path: /health-checker
    port: 8080
  initialDelaySeconds: 70
  periodSeconds: 30
  failureThreshold: 20
readinessProbe:
  httpGet:
    path: /health-checker
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 30
  failureThreshold: 20
startupProbe:
  httpGet:
    path: /health-checker
    port: 8080
  periodSeconds: 30
  failureThreshold: 20
nodeSelector: {}
tolerations: []
affinity: {}
### qtest-launch ###################################################
qtest-launch:
  enabled: false
  qTestLaunch:
    qTestLaunchDBName: qtest
    qTestLaunchDBUserName: postgres
    qTestLaunchDBPwd: cG9zdGdyZXM=
    qTestLaunchDBHostName: postgres.local
    qTestLaunchRootURL: https://launch.local
    qTestLaunchQTestURL: https://nephele.qtest.local
    qTestLaunchNodeTLSRejectUnAuthorized: "0"
    qTestLaunchTCPWD: "qTest"
    qTestLaunchPort: "3080"
    qTestLaunchDBSSLEnable: false
    qTestLaunchDBSSLMountPath: ""
    qTestLaunchDBSSL: ""
    qTestLaunchDBCRT: ""
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: false
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: qtest-launch-ingress
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: launch.qtest.local
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: qtest-launch-service
        pathType: ImplementationSpecific
        backendPort: 3080
    tls: []
    # - secretName: qtest-svc-tls
    #   hosts:
    #     - svc.qtest.com
    https: false
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 4
    healthApiPath: /health-check
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 1
      memory: 1Gi
### qtest-insights ###################################################
qtest-insights:
  enabled: false
  qTestInsights:
    qTestInsightsCatalinaOpts: \"-server -d64 -Xms512m -Xmx2048m -XX:MaxPermSize=256m -XX:CompileThreshold=8000 -XX:-DisableExplicitGC -XX:HeapDumpPath=/logs -Djava.awt.headless=true\"
    qTestInsightsDBName: qtest
    qTestInsightsDBUser: postgres
    qTestInsightsDBPassword: cG9zdGdyZXM=
    qTestInsightsDBHost: postgres.local
    qTestInsightsWriteQTestDBName: qtest
    qTestInsightsWriteQTestDBUser: postgres
    qTestInsightsWriteQTestDBPassword: cG9zdGdyZXM=
    qTestInsightsWriteQTestDBHost: postgres.local
    qTestInsightsSessionDBName: sessions
    qTestInsightsSessionDBUser: postgres
    qTestInsightsSessionDBPassword: cG9zdGdyZXM=
    qTestInsightsSessionDBHost: postgres.local
    qTestInsightsCSRFAllowPattern: \"$insights_security_csrf_trusted_source_pattern\"
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: false
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: qtest-insights-ingress
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: insights.qtest.local
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: insights-service
        pathType: ImplementationSpecific
        backendPort: 8080
    tls: []
    # - secretName: qtest-svc-tls
    #   hosts:
    #     - svc.qtest.com
    https: false
  persistence:
    enabled: false
    ## Set annotations on k8s pvc
    annotations: {}
    ## Specify an existing volume claim instead of creating a new one.
    ## When using this option all following options like storageClass, accessMode and size are ignored.
    ## existingClaim:

    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    storageClass:
    accessMode: ReadWriteOnce
    size: 5Gi
    ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    volumes: []
    ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    mounts: []
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 1
    healthApiPath: /rdLogon.aspx
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 1
      memory: 2Gi
### qtest-insights-etl ###################################################
qtest-insights-etl:
  enabled: false
  qTestInsightsEtl:
    qTestLogPath: /logs
    qTestUpdateDB: true
    qTestInsightsEtlDBName: qtest
    qTestInsightsEtlDBUser: postgres
    qTestInsightsEtlDBPassword: cG9zdGdyZXM=
    qTestInsightsEtlDBHost: postgres.local
    qTestInsightsEtlWriteQTestDBName: qtest
    qTestInsightsEtlWriteQTestDBUser: postgres
    qTestInsightsEtlWriteQTestDBPassword: cG9zdGdyZXM=
    qTestInsightsEtlWriteQTestDBHost: postgres.local
    qTestInsightsEtlSessionDBName: sessions
    qTestInsightsEtlSessionDBUser: postgres
    qTestInsightsEtlSessionDBPassword: cG9zdGdyZXM=
    qTestInsightsEtlSessionDBHost: postgres.local
    writeSessionsDBPassword: cG9zdGdyZXM=
    writeSessionsDBHost: postgres.local
    writeSessionsDBName: qtest
    writeSessionsDBUser: postgres
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: true
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: insights-etl-ingress
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: insights-etl.qtest.local
    paths: []
    extraPaths:
      - path: /*
        pathType: ImplementationSpecific
    tls: []
    # - secretName: qtest-svc-tls
    #   hosts:
    #     - svc.qtest.com
    https: false
  persistence:
    enabled: false
    ## Set annotations on pvc
    annotations: {}
    ## Specify an existing volume claim instead of creating a new one.
    ## When using this option all following options like storageClass, accessMode and size are ignored.
    # existingClaim:

    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    storageClass:
    accessMode: ReadWriteOnce
    size: 5Gi
    ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    volumes: []
    ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    mounts: []
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 1
    healthApiPath: /ping
    targetPort: 8765
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 1
      memory: 2Gi
### qtest-parameters ###################################################
qtest-parameters:
  enabled: false
  qTestParameters:
    qTestParametersDBName: parameters
    qTestParametersDBUserName: postgres
    qTestParametersDBPwd: cG9zdGdyZXM=
    qTestParametersDBHostName: postgres.local
    qTestParametersQTestHost: https://nephele.qtest.local
    qTestParametersNodeTLSRejectUnAuthorized: "0"
    qTestParametersNodeEnv: production
    qTestParametersPort: 5080
    qTestParametersDBSSLEnable: false
    qTestParametersDBSSLMountPath: ""
    qTestParametersDBSSL: ""
    qTestParametersDBCRT: ""
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: false
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: qtest-parameters-ingress
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: parameters.qtest.local
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: qtest-parameters-service
        pathType: ImplementationSpecific
        backendPort: 5080
    tls: []
    # - secretName: qtest-svc-tls
    #   hosts:
    #     - svc.qtest.com
    https: false
  persistence:
    enabled: false
    ## Set annotations on pvc
    annotations: {}
    storageClass:
    accessMode: ReadWriteOnce
    size: 5Gi
    ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    volumes: []
    ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    mounts: []
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 4
    healthApiPath: /health-check
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 1
      memory: 1Gi
### qtest-pulse ###################################################
qtest-pulse:
  enabled: false
  qTestPulse:
    qTestPulseDBName: pulse
    qTestPulseDBUserName: postgres
    qTestPulseDBHostName: host.docker.internal
    qTestPulseDBPwd: cG9zdGdyZXM=
    qTestPulsePort: "4080"
    qTestPulseNodeEnv: production
    qTestPulseRootURL: https://pulse.qtest.local
    qTestPulseQTestURL: https://nephele.qtest.local
    qTestPulseScenarioURL: https://scenario.local
    qTestPulseNodeTLSRejectUnAuthorized: "0"
    qTestPulseDBSSLEnable: false
    qTestPulseDBSSLMountPath: ""
    qTestPulseDBSSL: ""
    qTestPulseDBCRT: ""
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: false
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: pulse-nginx
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: pulse.qtest.local
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: qtest-pulse-service
        pathType: ImplementationSpecific
        backendPort: 4080
    tls: []
    # - secretName: pulse-qtest-local-tls
    # hosts:
    # - pulse.qtest.local
    https: false
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 4
    healthApiPath: /
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 1
      memory: 1Gi
### qtest-scenario ###################################################
# git@github.com:QAS-Labs/qtest-scenario.git
qtest-scenario:
  enabled: false
  qTestScenario:
    qTestScenarioDBName: scenario
    qTestScenarioDBUserName: postgres
    qTestScenarioDBPwd: cG9zdGdyZXM=
    qTestScenarioDBHostName: host.docker.internal
    qTestScenarioPort: "6080"
    qTestScenarioLocalBaseURL: https://scenario.local
    qTestScenarioNodeTLSRejectUnAuthorized: "0"
    qTestScenarioNodeEnvironment: production
    qTestScenarioRefreshTokenSecret: ""
    qTestScenarioAppKeyDescriptor: ""
    qTestScenarioQTestURL: https://nephele.qtest.local
    qTestScenarioDBSSLEnable: false
    qTestScenarioDBSSLMountPath: ""
    qTestScenarioDBSSL: ""
    qTestScenarioDBCRT: ""
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: true
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: scenario-nginx
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: qtest.svc.com
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: qtest-scenario-service
        pathType: ImplementationSpecific
        backendPort: 6080
    tls: []
    # - secretName: qtest-svc-tls
    #   hosts:
    #     - svc.qtest.com
    https: false
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 4
    healthApiPath: /atlassian-connect.json
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 1
      memory: 1Gi
### qtest-session ###################################################
qtest-session:
  enabled: false
  qTestSession:
    qTestSessionJSHome: /usr/local/sessions-js
    qTestSessionNodeEnvironment: production
    qTestSessionPort: "8080"
    qTestSessionDBName: sessions
    qTestSessionDBUserName: postgres
    qTestSessionDBPwd: cG9zdGdyZXM=
    qTestSessionDBHostName: host.docker.internal
    qTestManagerHost: https://nephele.qtest.local
    qTestSessionMasterToken: Qtoy
    qTestSessionStorageRootPath: /data
    qTestSessionSecretKey: Q3AyVEJYQ0lHb3N3dWs1eklwTG1nQm1QRkxWMDVrU1RKRHBWMXNaM3Y4VVBoWFBZMERzaERVdmwwOW1seVdETw==
    qTestStorageBucketName: aws-session-bucket-name
    qTestSessionClamavURL: http://clam.qtest.local
    qTestSessionStorageType: amazon_s3
    qTestSessionDBSSLEnable: false
    qTestSessionDBSSLMountPath: ""
    qTestSessionDBSSL: ""
    qTestSessionDBCRT: ""
  #### Ingress/IngressClass (> K8s 1.18-1.22+) #####
  ingressClass:
    enabled: true
    labels: {}
    controller: ingress.k8s.aws/alb
    isDefaultClass: true
    # Use to force a networking.k8s.io API Version for certain CI/CD applications. Ex. "v1"
    fallbackApiVersion: ""
  ingress:
    enabled: true
    name: session-nginx
    labels: {}
    annotations: {}
    canary:
      annotationPrefix: ""
      annotations: {}
      # canary-by-header: []
      # canary-by-header-pattern: []
    hosts:
      host: qtest.svc.com
    paths: []
    extraPaths:
      - path: /*
        backendServiceName: qtest-session-service
        pathType: ImplementationSpecific
        backendPort: 8080
    tls: []
    https: false
  persistence:
    enabled: false
    ## Set annotations on pvc
    annotations: {}
    ## Specify an existing volume claim instead of creating a new one.
    ## When using this option all following options like storageClass, accessMode and size are ignored.
    # existingClaim:

    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    storageClass:
    accessMode: ReadWriteOnce
    size: 5Gi
    ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    volumes: []
    ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    mounts: []
  # VPA values
  vpaAutoscaling:
    enabled: false
    updatePolicy:
      updateMode: "Off"
  # HPA values
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 4
    healthApiPath: /health-check
    periodSeconds: 30
    failureThreshold: 4
    targetCPUUtilizationPercentage: 85
    targetMemoryUtilizationPercentage: 85
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 1
      memory: 1Gi
